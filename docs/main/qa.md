# Вопросы и ответы - Vuege

**Псевдонимы**: файл вопросов

Этот файл содержит ответы на часто задаваемые вопросы по архитектуре, технологиям и процессу разработки проекта.

## Порядок формирования записи в файле

### Система нумерации вопросов
Вопросы нумеруются по шаблону: **QN** (Q1, Q2, Q3...)
- **Q** - префикс для обозначения вопроса (Question)
- **N** - порядковый номер вопроса

### Категории вопросов
- **Архитектурные вопросы** - вопросы по архитектуре системы
- **Технические вопросы** - вопросы по технологиям и реализации
- **Вопросы производительности** - вопросы по оптимизации
- **Вопросы процесса разработки** - вопросы по методологии

### Структура записи вопроса
```
### QN: [Краткое описание вопроса]
**A:** [Подробный ответ с обоснованием]

**Дополнительные детали:**
- **Пункт 1**: Объяснение
- **Пункт 2**: Объяснение
- **Пункт 3**: Объяснение
```

### Принципы ведения
- **Логичность**: Вопросы группируются по категориям
- **Полнота**: Ответы должны быть исчерпывающими
- **Обоснованность**: Каждое решение должно быть обосновано
- **Актуальность**: Регулярное обновление при изменении архитектуры

## Список вопросов

### Архитектурные вопросы

### Q1: Почему выбран Java 21 вместо Java 24?
**A:** Java 21 является LTS (Long Term Support) версией, что обеспечивает стабильность и долгосрочную поддержку. Java 24 еще не является LTS и может содержать нестабильные изменения. Для продакшн-системы важна стабильность.

### Q2: Почему PostgreSQL вместо MS SQL Server?
**A:** 
- **Открытость**: PostgreSQL - открытая СУБД
- **ГИС-поддержка**: PostGIS обеспечивает отличную поддержку геопространственных данных
- **Исторические даты**: PostgreSQL поддерживает даты от 4713 BC до 5874897 AD
- **Стоимость**: Бесплатная лицензия
- **Сообщество**: Активное сообщество разработчиков

### Q3: Зачем нужен TypeScript?
**A:** 
- **Сложная доменная модель**: Vuege имеет сложные сущности с множественными связями
- **Исторические данные**: Требуют строгой типизации для предотвращения ошибок
- **ГИС-функциональность**: Пространственные данные требуют точной типизации
- **TanStack Router**: Требует TypeScript для полной функциональности
- **Масштабируемость**: TypeScript упрощает поддержку больших проектов

### Q4: Почему TanStack Router вместо Vue Router?
**A:** 
- **Полная реактивность**: TanStack Router полностью реактивный
- **Type-safe**: Обеспечивает типобезопасность маршрутизации
- **GraphQL интеграция**: Лучшая интеграция с GraphQL
- **Валидация параметров**: Встроенная валидация URL параметров
- **Производительность**: Оптимизирован для Vue 3

### Q5: Зачем нужен Liquibase?
**A:** 
- **Версионирование схемы**: Отслеживание всех изменений БД
- **Безопасность**: Атомарные операции и откат изменений
- **Команда**: Несколько разработчиков могут безопасно изменять схему
- **Продакшн**: Безопасное развертывание в продакшн
- **История**: Полная история изменений схемы

## Технические вопросы

### Q6: Как обрабатываются исторические даты (4000 лет до н.э.)?
**A:** 
- **PostgreSQL DATE**: Поддерживает диапазон 4713 BC до 5874897 AD
- **Валидация**: Проверка корректности исторических дат
- **Точность**: Указание точности даты (день, месяц, год, век)
- **Эры**: Поддержка BC (до н.э.) и AD (н.э.)
- **Источники**: Указание источников исторических данных

### Q7: Как реализована ГИС-функциональность?
**A:** 
- **PostGIS**: Расширение PostgreSQL для геопространственных данных
- **Пространственные типы**: POINT, POLYGON, LINESTRING
- **Индексы**: GIST индексы для быстрого поиска
- **Запросы**: Пространственные запросы (в пределах, пересечения)
- **Координаты**: WGS84 (EPSG:4326) система координат

### Q8: Как обеспечивается реактивность?
**A:** 
- **Backend**: Spring WebFlux + R2DBC (реактивный доступ к БД)
- **API**: GraphQL с поддержкой реактивных потоков
- **Frontend**: Vue.js 3 + TanStack Router (реактивная маршрутизация)
- **Клиент**: Apollo Client (реактивный GraphQL клиент)
- **UI**: Quasar (реактивные компоненты)

### Q9: Как работает единый JAR-артефакт?
**A:** 
- **Maven**: Сборка Backend в JAR
- **frontend-maven-plugin**: Сборка Frontend
- **Копирование**: Frontend копируется в static папку JAR
- **Tomcat**: Обслуживает и Backend, и Frontend
- **Контейнер**: Единый образ с JAR и PostgreSQL

### Q10: Как обеспечивается безопасность?
**A:** 
- **HTTPS**: Шифрование трафика
- **JWT**: Токены аутентификации
- **RBAC**: Ролевая модель доступа
- **Валидация**: Проверка входных данных
- **SQL Injection**: Защита через R2DBC
- **XSS**: Защита через Vue.js

## Вопросы производительности

### Q11: Как оптимизируется производительность?
**A:** 
- **Индексы**: Оптимизированные индексы БД
- **Кэширование**: Redis для кэширования
- **Lazy loading**: Ленивая загрузка данных
- **Code splitting**: Разделение кода на чанки
- **CDN**: Доставка статики через CDN
- **Мониторинг**: Отслеживание производительности

### Q12: Как обрабатываются большие объемы исторических данных?
**A:** 
- **Партиционирование**: Разделение таблиц по периодам
- **Индексы**: Специальные индексы для исторических данных
- **Пагинация**: Постраничная загрузка данных
- **Фильтрация**: Эффективная фильтрация по периодам
- **Кэширование**: Кэширование часто запрашиваемых данных

## Вопросы по процессу разработки

### Q13: Как отслеживаются долговременные проблемы проекта?
**A:** 
- **Система учета**: Файл `docs/main/problems.md` для долговременных проблем
- **Нумерация**: Система YYMMDD-NN для уникальной идентификации
- **Статусы**: Актуальна/Решена/Потеряла актуальность
- **История**: Детальная история попыток решения с анализом причин
- **Интеграция**: Связи с другими документами проекта
- **Пример**: Проблема [P250816-01] с установкой Terminal MCP Server

### Q13: Как масштабируется система?
**A:** 
- **Горизонтальное масштабирование**: Несколько экземпляров приложения
- **Балансировка нагрузки**: Распределение запросов
- **Шардинг БД**: Разделение данных по шардам
- **Микросервисы**: Возможность разделения на микросервисы
- **Контейнеризация**: Docker для простого развертывания

## Вопросы разработки

### Q14: Как организована разработка?
**A:** 
- **Git**: Система контроля версий
- **Ветки**: Feature branches для новых функций
- **Code review**: Обязательный review кода
- **CI/CD**: Автоматическая сборка и развертывание
- **Тестирование**: Unit, integration, E2E тесты

### Q15: Как обеспечивается качество кода?
**A:** 
- **TypeScript**: Строгая типизация
- **ESLint**: Линтинг кода
- **Prettier**: Форматирование кода
- **Pre-commit hooks**: Проверка перед коммитом
- **Code review**: Обязательный review
- **Lombok**: Минимизация boilerplate кода в Java

### Q16: Как документируется код?
**A:** 
- **JSDoc**: Документация функций
- **JavaDoc**: Документация Java классов
- **Lombok Documentation**: Документация аннотаций
- **GraphQL Schema**: Документация API
- **README**: Документация проекта
- **Changelog**: История изменений
- **Diary**: Технический дневник

## Вопросы развертывания

### Q17: Как развертывается система?
**A:** 
- **Docker**: Контейнеризация приложения
- **docker-compose**: Оркестрация контейнеров
- **JAR-артефакт**: Единый артефакт для развертывания
- **PostgreSQL**: База данных в том же контейнере
- **Nginx**: Обратный прокси (опционально)

### Q18: Как обеспечивается отказоустойчивость?
**A:** 
- **Health checks**: Проверка состояния сервисов
- **Мониторинг**: Отслеживание состояния системы
- **Логирование**: Детальное логирование
- **Backup**: Регулярное резервное копирование
- **Disaster recovery**: План восстановления

### Q19: Как обновляется система?
**A:** 
- **Liquibase**: Миграции схемы БД
- **Blue-green deployment**: Безопасное обновление
- **Rollback**: Возможность отката изменений
- **Тестирование**: Тестирование перед развертыванием
- **Мониторинг**: Отслеживание после обновления

## Вопросы поддержки

### Q20: Как обеспечивается поддержка пользователей?
**A:** 
- **Документация**: Подробная пользовательская документация
- **API документация**: Автоматически генерируемая документация
- **Видеоуроки**: Обучающие материалы
- **Поддержка**: Система поддержки пользователей
- **Обучение**: Программы обучения

### Q21: Как обрабатываются ошибки?
**A:** 
- **Логирование**: Детальное логирование ошибок
- **Мониторинг**: Отслеживание ошибок в реальном времени
- **Алерты**: Уведомления о критических ошибках
- **Анализ**: Анализ причин ошибок
- **Исправление**: Быстрое исправление проблем

## Вопросы по доменной модели

### Q22: Как моделируются организационные единицы?
**A:** 
- **Иерархия**: Поддержка родительских и дочерних единиц
- **Типы**: Государства, правительственные, коммерческие организации
- **Жизненный цикл**: Создание, трансформации, ликвидация
- **Историчность**: Отслеживание изменений во времени
- **География**: Привязка к географическим координатам

### Q23: Как обрабатываются должности?
**A:** 
- **Иерархия**: Позиции в организационной структуре
- **Ответственности**: Описание обязанностей
- **Историчность**: Отслеживание изменений должностей
- **Связи**: Связь с людьми и организациями
- **Валидация**: Проверка корректности данных

### Q24: Как моделируются люди?
**A:** 
- **Профили**: Полная информация о человеке
- **Позиции**: История занимаемых должностей
- **Национальность**: Учет гражданства
- **Историчность**: Отслеживание жизненного пути
- **Источники**: Указание источников информации

## Вопросы по ГИС

### Q25: Какие картографические сервисы поддерживаются?
**A:** 
- **OpenStreetMap**: Бесплатные карты
- **Google Maps**: Коммерческие карты
- **Bing Maps**: Альтернативные карты
- **Кастомные карты**: Собственные картографические данные
- **Исторические карты**: Карты прошлых эпох

### Q26: Как работает геокодирование?
**A:** 
- **Прямое геокодирование**: Адрес → координаты
- **Обратное геокодирование**: Координаты → адрес
- **Историческое геокодирование**: Геокодирование для прошлых эпох
- **Валидация**: Проверка корректности координат
- **Кэширование**: Кэширование результатов

### Q27: Как обрабатываются пространственные запросы?
**A:** 
- **Поиск в пределах**: Поиск объектов в заданной области
- **Расстояния**: Вычисление расстояний между объектами
- **Пересечения**: Поиск пересечений геометрий
- **Индексы**: Пространственные индексы для быстрого поиска
- **Оптимизация**: Оптимизация пространственных запросов

## Вопросы по историческим данным

### Q28: Как валидируются исторические даты?
**A:** 
- **Диапазон**: Проверка в пределах допустимого диапазона
- **Логика**: Проверка логической корректности дат
- **Источники**: Учет надежности источников
- **Точность**: Указание точности датировки
- **Консистентность**: Проверка согласованности данных

### Q29: Как отображаются временные шкалы?
**A:** 
- **Интерактивные шкалы**: Интерактивные временные шкалы
- **Фильтрация**: Фильтрация по временным периодам
- **Анимация**: Анимированное отображение изменений
- **Слои**: Слои для разных исторических периодов
- **Синхронизация**: Синхронизация с картами

### Q30: Как обрабатываются исторические источники?
**A:** 
- **Каталогизация**: Систематизация источников
- **Достоверность**: Оценка надежности источников
- **Цитирование**: Правильное цитирование источников
- **Версионирование**: Отслеживание изменений в источниках
- **Архивирование**: Сохранение исторических данных

### Q31: Зачем нужен Lombok в проекте?
**A:** 
- **Меньше кода**: Автоматическая генерация геттеров, сеттеров, конструкторов
- **Меньше ошибок**: Снижение вероятности ошибок в boilerplate коде
- **Лучшая читаемость**: Фокус на бизнес-логике, а не на технических деталях
- **Стандартизация**: Единый подход к созданию моделей
- **Производительность**: Меньше кода для компиляции

### Q32: Какие аннотации Lombok используются в проекте?
**A:** 
- **@Data**: Геттеры, сеттеры, toString, equals, hashCode для моделей
- **@Builder**: Паттерн Builder для создания объектов
- **@NoArgsConstructor**: Конструктор без параметров
- **@AllArgsConstructor**: Конструктор со всеми параметрами
- **@Slf4j**: Автоматическое логирование для сервисов и контроллеров
- **@RequiredArgsConstructor**: Конструктор с обязательными параметрами для DI
